'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var tabs = require('@hiendv/tabs');
var octiconsVue = require('octicons-vue');

var Tab = {
  name: 'Tab',
  functional: true,
  props: {
    title: {
      type: String,
      default () {
        return 'Title'
      }
    },
    icon: {
      type: Object,
      default () {
        return {
          attrs () {},
          path () {}
        }
      }
    },
    hash: {
      type: String,
      default: null
    },
    end: {
      type: Boolean,
      default: false
    },
    ghost: {
      type: Boolean,
      default: false
    }
  },
  render (h, context) {
    if (context.props.ghost) {
      return h('div', context)
    }

    if (!context.scopedSlots.default) {
      return h('div', context)
    }

    return h('div', context, context.scopedSlots.default())
  }
};

var TabItem = {
  functional: true,
  inject: ['theme'],
  props: {
    nav: {
      type: Function,
      default: undefined
    },
    item: {
      type: Object,
      required: true
    }
  },
  render (h, ctx) {
    const { data, props, injections } = ctx;
    if (typeof props.nav === 'function') {
      return props.nav(data)
    }

    const children = [
      props.item.title
    ];

    if (props.item.icon.attrs()) {
      children[0] = h('span', {}, children[0]);
      children.unshift([
        h(octiconsVue.Octicon, { props: { icon: props.item.icon, className: injections.theme.octicon } }),
        ' '
      ]);
    }

    data.attrs.href = '#';
    return h('a', data, children)
  }
};

var TabPanel = {
  name: 'TabPanel',
  functional: true,
  props: {
    item: {
      type: Object,
      default () {
        return {
          data: {},
          children: []
        }
      }
    }
  },
  render (h, context) {
    const { data, props } = context;
    return h('div', tabs.deepmerge(data, props.item.data.data), props.item.children)
  }
};

var TabPanelStateful = {
  name: 'TabPanelStateful',
  props: {
    item: {
      type: Object,
      default () {
        return {
          data: {},
          children: []
        }
      }
    }
  },
  render (h) {
    return h('div', this.item.data.data, this.item.children)
  }
};

//

var script = {
  components: { TabItem, TabPanel, TabPanelStateful },
  provide () {
    return {
      theme: this.theme
    }
  },
  props: {
    theme: {
      type: Object,
      default () {
        return tabs.themeDefault
      }
    },
    show: {
      type: Number,
      default: 0
    },
    keepAlive: {
      type: Boolean,
      default: false
    },
    hold: {
      type: [Boolean, Function],
      default: false
    }
  },
  data () {
    return {
      active: 0,
      slots: []
    }
  },
  computed: {
    validChildren () {
      return this.slots.filter(vnode => vnode && vnode.fnOptions && vnode.fnOptions.name === 'Tab' && vnode.data)
    },
    items () {
      return this.validChildren.map(vnode => vnode.data.props)
    },
    navs () {
      return this.validChildren.map(vnode => vnode.data.scopedSlots.nav)
    },
    listeners () {
      return this.validChildren.map(vnode => vnode.data.listeners)
    },
    activePanel () {
      return this.validChildren.find((panel, i) => this.isActive(i))
    }
  },
  watch: {
    show: {
      immediate: true,
      handler (val) {
        this.active = val;
      }
    },
    items () {
      this.syncActiveHash();
    }
  },
  created () {
    this.loadSlots();
  },
  updated () {
    // Because $slots is not reactive we need these below lines for hot-reloading
    if (!this.$slots.default || !this.$slots.default.length) {
      return
    }

    if (this.$slots.default === this.slots) {
      // idk how but this comparison of objects just works o.O
      return
    }

    this.loadSlots();
  },
  methods: {
    currentHash () {
      return (this.$route ? this.$route.hash : window.location.hash).substring(1)
    },
    itemClicked (index) {
      const item = this.items[index];
      if (item.ghost) {
        return
      }

      if (typeof this.hold === 'boolean' && this.hold) {
        return
      }

      if (typeof this.hold === 'function' && this.hold(item, index)) {
        return
      }

      return this.setActive(index)
    },
    isActive (index) {
      if (index === this.active) {
        return true
      }

      return false
    },
    setHash (index) {
      const hash = this.currentHash();
      const item = this.items[index];
      if (hash === item.hash) {
        return
      }

      if (this.$route && !hash && !item.hash) {
        return
      }

      if (this.$route) {
        this.$router.replace({ hash: item.hash });
        return
      }

      tabs.setHash(item.hash);
    },
    syncActiveHash () {
      const hash = this.currentHash();
      const index = this.items.findIndex(element => {
        return element.hash === hash
      });

      if (index < 0) {
        return
      }

      this.setActive(index);
    },
    setActive (index) {
      this.setHash(index);
      this.active = index;
      this.$emit('update:show', index);
    },
    loadSlots () {
      this.slots = this.$slots.default || [];
    }
  }
};

function normalizeComponent(template, style, script, scopeId, isFunctionalTemplate, moduleIdentifier /* server only */, shadowMode, createInjector, createInjectorSSR, createInjectorShadow) {
    if (typeof shadowMode !== 'boolean') {
        createInjectorSSR = createInjector;
        createInjector = shadowMode;
        shadowMode = false;
    }
    // Vue.extend constructor export interop.
    const options = typeof script === 'function' ? script.options : script;
    // render functions
    if (template && template.render) {
        options.render = template.render;
        options.staticRenderFns = template.staticRenderFns;
        options._compiled = true;
        // functional template
        if (isFunctionalTemplate) {
            options.functional = true;
        }
    }
    // scopedId
    if (scopeId) {
        options._scopeId = scopeId;
    }
    let hook;
    if (moduleIdentifier) {
        // server build
        hook = function (context) {
            // 2.3 injection
            context =
                context || // cached call
                    (this.$vnode && this.$vnode.ssrContext) || // stateful
                    (this.parent && this.parent.$vnode && this.parent.$vnode.ssrContext); // functional
            // 2.2 with runInNewContext: true
            if (!context && typeof __VUE_SSR_CONTEXT__ !== 'undefined') {
                context = __VUE_SSR_CONTEXT__;
            }
            // inject component styles
            if (style) {
                style.call(this, createInjectorSSR(context));
            }
            // register component module identifier for async chunk inference
            if (context && context._registeredComponents) {
                context._registeredComponents.add(moduleIdentifier);
            }
        };
        // used by ssr in case component is cached and beforeCreate
        // never gets called
        options._ssrRegister = hook;
    }
    else if (style) {
        hook = shadowMode
            ? function (context) {
                style.call(this, createInjectorShadow(context, this.$root.$options.shadowRoot));
            }
            : function (context) {
                style.call(this, createInjector(context));
            };
    }
    if (hook) {
        if (options.functional) {
            // register for functional component in vue file
            const originalRender = options.render;
            options.render = function renderWithStyleInjection(h, context) {
                hook.call(context);
                return originalRender(h, context);
            };
        }
        else {
            // inject component registration as beforeCreate hook
            const existing = options.beforeCreate;
            options.beforeCreate = existing ? [].concat(existing, hook) : [hook];
        }
    }
    return script;
}

const isOldIE = typeof navigator !== 'undefined' &&
    /msie [6-9]\\b/.test(navigator.userAgent.toLowerCase());
function createInjector(context) {
    return (id, style) => addStyle(id, style);
}
let HEAD;
const styles = {};
function addStyle(id, css) {
    const group = isOldIE ? css.media || 'default' : id;
    const style = styles[group] || (styles[group] = { ids: new Set(), styles: [] });
    if (!style.ids.has(id)) {
        style.ids.add(id);
        let code = css.source;
        if (css.map) {
            // https://developer.chrome.com/devtools/docs/javascript-debugging
            // this makes source maps inside style tags work properly in Chrome
            code += '\n/*# sourceURL=' + css.map.sources[0] + ' */';
            // http://stackoverflow.com/a/26603875
            code +=
                '\n/*# sourceMappingURL=data:application/json;base64,' +
                    btoa(unescape(encodeURIComponent(JSON.stringify(css.map)))) +
                    ' */';
        }
        if (!style.element) {
            style.element = document.createElement('style');
            style.element.type = 'text/css';
            if (css.media)
                style.element.setAttribute('media', css.media);
            if (HEAD === undefined) {
                HEAD = document.head || document.getElementsByTagName('head')[0];
            }
            HEAD.appendChild(style.element);
        }
        if ('styleSheet' in style.element) {
            style.styles.push(code);
            style.element.styleSheet.cssText = style.styles
                .filter(Boolean)
                .join('\n');
        }
        else {
            const index = style.ids.size - 1;
            const textNode = document.createTextNode(code);
            const nodes = style.element.childNodes;
            if (nodes[index])
                style.element.removeChild(nodes[index]);
            if (nodes.length)
                style.element.insertBefore(textNode, nodes[index]);
            else
                style.element.appendChild(textNode);
        }
    }
}

/* script */
const __vue_script__ = script;

/* template */
var __vue_render__ = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',{class:_vm.theme.tabs},[_vm._t("nav",function(){return [_c('nav',{class:_vm.theme.items},_vm._l((_vm.items),function(item,index){
var _obj;
return _c('tab-item',_vm._g({key:index,class:( _obj = {}, _obj[_vm.theme.item] = true, _obj[_vm.theme['item--active']] = _vm.isActive(index), _obj[_vm.theme['item--end']] = item.end, _obj ),attrs:{"nav":_vm.navs[index],"item":item},on:{"click":function($event){$event.preventDefault();return _vm.itemClicked(index)}}},_vm.listeners[index]))}),1)]},{"items":_vm.items}),_vm._v(" "),_c('transition',{attrs:{"tag":"div","name":"slide-down","mode":"out-in"}},[(_vm.keepAlive)?_c('keep-alive',{attrs:{"max":5}},[_c('tab-panel-stateful',{key:_vm.active,class:_vm.theme.panel,attrs:{"item":_vm.activePanel}})],1):_c('tab-panel',{key:_vm.active,class:_vm.theme.panel,attrs:{"item":_vm.activePanel}})],1)],2)};
var __vue_staticRenderFns__ = [];

  /* style */
  const __vue_inject_styles__ = function (inject) {
    if (!inject) return
    inject("data-v-8637b6da_0", { source: ".slide-down-enter-active{transition:opacity .15s ease,transform .15s ease}.slide-down-leave-active{transition:opacity .15s cubic-bezier(1,.5,.8,1),transform .15s cubic-bezier(1,.5,.8,1)}.slide-down-enter,.slide-down-leave-to{opacity:0;transform:translateY(10px)}", map: undefined, media: undefined });

  };
  /* scoped */
  const __vue_scope_id__ = undefined;
  /* module identifier */
  const __vue_module_identifier__ = undefined;
  /* functional template */
  const __vue_is_functional_template__ = false;
  /* style inject SSR */
  
  /* style inject shadow dom */
  

  
  const __vue_component__ = /*#__PURE__*/normalizeComponent(
    { render: __vue_render__, staticRenderFns: __vue_staticRenderFns__ },
    __vue_inject_styles__,
    __vue_script__,
    __vue_scope_id__,
    __vue_is_functional_template__,
    __vue_module_identifier__,
    false,
    createInjector,
    undefined,
    undefined
  );

exports.Tab = Tab;
exports.Tabs = __vue_component__;
Object.keys(tabs).forEach(function (k) {
  if (k !== 'default' && !exports.hasOwnProperty(k)) Object.defineProperty(exports, k, {
    enumerable: true,
    get: function () {
      return tabs[k];
    }
  });
});
